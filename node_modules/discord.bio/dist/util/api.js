"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
const node_fetch_1 = __importDefault(require("node-fetch"));
const DBioAPIError_1 = __importDefault(require("../structures/DBioAPIError"));
const constants = __importStar(require("./Constants"));
/**
 * API shortcut
 * @param path The api route including the first /
 * @param method The HTTP request method
 * @param headers Custom headers
 * @param body Request body
 */
async function api(path, method, headers, body) {
    if (this.__quota <= this.__outgoing_requests) {
        return new Promise(resolve => {
            if (this.__quota_reset - Date.now() > 0)
                setTimeout(() => {
                    resolve(this.api(path, method, headers, body));
                }, this.__quota_reset - Date.now());
            //Prevent race condition
            //if this is removed it will result in an OOM 
            else
                setTimeout(() => {
                    resolve(this.api(path, method, headers, body));
                }, 60000);
        });
    }
    if (!headers)
        headers = {};
    Object.keys(constants.headers).forEach(key => {
        if (typeof headers[key] === 'undefined')
            headers[key] = constants.headers[key];
    });
    this.__outgoing_requests += 1;
    const response = await node_fetch_1.default(this.baseURL + path, {
        method: method,
        headers: headers,
        body: body
    });
    this.__outgoing_requests -= 1;
    const text = await response.text();
    this.emit('debug', `[API Response] ${text}`);
    if (response.status === 429) { //Rate Limit. This should never happen.
        this.emit('rateLimit', 
        /**
         * Number of seconds until you can send a request again
         */
        parseInt(response.headers.get('retry-after')));
        return new Promise(resolve => {
            setTimeout(() => {
                resolve(this.api(path, method, headers, body));
            }, parseInt(response.headers.get('retry-after')));
        });
    }
    this.__quota_reset = parseInt(response.headers.get('x-ratelimit-reset')) * 1000;
    this.__quota = parseInt(response.headers.get('x-ratelimit-remaining'));
    let result;
    try {
        result = JSON.parse(text);
    }
    catch (error) { }
    if (!result) {
        if (response.ok)
            return;
        else
            throw new DBioAPIError_1.default({ message: response.statusText, path: path, method: method, statusCode: response.status });
    }
    if (typeof result.success !== 'boolean' && response.ok)
        return result;
    if (result.success === false || !response.ok)
        throw new DBioAPIError_1.default({ message: result.message || response.statusText.toString(), path: path, method: method, statusCode: response.status });
    return result;
}
module.exports = api;
//# sourceMappingURL=api.js.map